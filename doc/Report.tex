\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{indentfirst}
\usepackage[a4paper, total={6.5in, 10in}]{geometry}
\usepackage{svg}
\usepackage{wrapfig}


\let\LaTeXsubsection\subsubsection
\def\subsubsection{\setlength{\parindent}{5mm}\LaTeXsubsection}

\usepackage{titling}
\setlength{\droptitle}{-2em}

\usepackage{enumitem}
\setlist{leftmargin=5.5mm}

\newenvironment{myquote}%
  {\list{}{\leftmargin=0.0in\rightmargin=0.0in}\item[]}%
  {\endlist}

\begin{document}

\title{\textbf{TapATune - C Project \\Final Report}}
\author{Shravan Nageswaran, Jason Lipowicz,\\ Alexandr Zakon, Boaz Francis}
\date{20th June 2017}

\maketitle

\vspace{0.2in}

\section{Implementing the Assembler}

\subsection{Creation of a Symbol Table}

After creating an emulator to read and execute a binary file, our next task was to create an assembler to output ARM-binary code to a source file. Creating the assembler was broken into two steps. The first step was for the group to create a \emph{symbol table} to associate labels with memory addresses. The setup of the symbol table was accomplished through creating two \emph{structs} in C. One improvement that we made while creating objects in the assembler compared to creating objects in the emulator was the fact that we preceded each struct with \texttt{typedef}. This allowed us to call the symbol table in other programs without preceding the call with the word \texttt{struct}. In order to define the symbol table, we had to first create a separate typedef, which we called \texttt{Map}. A Map contained a char pointer to the label, and an integer to its corresponding address. Meanwhile, we created another typedef, called \texttt{SymbolTable}, which contained an array of Maps, and an integer corresponding to its size.

\subsection{Generating Instructions}

Once the symbol table structure was created, we had to write code for the assembler to generate binary encodings of instructions that are passed through opcode \emph{mnemonics}. This was the second pass of the assembler's \emph{two-pass} setup. The second pass consisted of two major designs. The first task was to create a tokenizer to break each line into its label. Using the \textbf{strtok\_r} and \textbf{strtol} functions in C, this was quite easy, and we finished this task quickly as a group. the second task was to write functions for the assembler to assemble instructions, where each opcode was mapped to its expected operand count using the aforementioned symbol table abstract data type. Similar to coding the emulator, there were four instructions that we had to code: data processing, multiply, single data transfer, and branch. Thus, we assigned each group member an instruction to handle, and in turn the dynamic of the group in Part II was notably smoother than its dynamic in Part I. Tasks were distributed much more efficiently, which led to a faster completion of the assembler. However, this required more time to be spent on standardizing the code format, as many parts of the second pass of the assembler were coded independently.

\section{Extension}

\subsection{Concept}

Creating the assembler and emulator made us appreciate the designs of computer architecture. However, for our extension, we also wanted to immerse ourselves in the interactive aspects of C, and we endeavored to create an extension that would let us use GUIs, I/O, etc. Our main objective was to create an extension that would respond in real-time to user input, so we decided to code a game similar to the classic video game \emph{Guitar Hero}. Our vision for this was the synchronization of an animated GUI with chosen sound files. Different coloured buttons would flash on the GUI, which would correspond to ``notes" generated from the sound file. The user would have to press the corresponding key to the button on the keyboard before the next button presented itself.

\subsection{Design}

\begin{wrapfigure}{R}{0.3\textwidth}
  \centering
  \includesvg[width = 90pt]{keypress}
\end{wrapfigure}


Having all played Guitar Hero in our childhoods at one point or another, we had an idea of where to start in order to successfully implement our extension. We split into groups of two to do some preliminary research on how to implement sound and GUIs in C. Notably, progress in the graphics area was made much faster than progress in the sound area, as we were able to quickly code a user interface for our game. One member of the group also was quickly able to setup a program which read user input through the keyboard. This was important as it corresponded to the user's pressing of the GUI's buttons, each of which represented a different guitar string.
\\ \hspace{10mm} As is good practice in C, we created a header file, called \texttt{ctap.h}, which consisted of numerous constant, enumeration, struct, and function definitions. A button was represented as a struct, with characteristics from the \texttt{GtkWidget} platform in C. We were able to code the graphics within three days, after which we started to make tests on the graphics, while we waited to integrate the sound component of the extension.
\\ \hspace{10mm} Once we were able to figure out how to play a sound, using the SDL Mixer platform, the ball was rolling. We extended our progress to have the program play multiple songs at once, to create a more realistic interpretation of a guitar. We were now able to read sounds from a file, read user input, and integrate both into our advanced graphics. Our game has come along nicely.

\subsection{Challenges}

\begin{itemize}

\item Lag/Memory - The GUI that we coded initially encountered a tremendous amount of lag as the buttons were falling down the screen. To fix this, we optimized the graphics so that the buttons would immediately free memory after their termination. This also improved lag time.

\item Playing Multiple Sounds - This challenge was fixed through copious amounts of research. We were trying to play sounds simultaneously along with the GUI, so we could also respond to the pressing of multiple buttons. This was finally accomplished after thorough research and extensive development.

\item Loop Delay (Assembler) - Going back to the assembler, there were times when certain test cases would not pass on certain computers - namely, the tests with loops. We found that if other processes were running in the background of the tests, then the code would take longer to run, ultimately failing our tests. We accounted for this interference in our updated code and ultimately ran the tests on machines that were not busy. This was how the tests were intended to be run, and the initial ones that failed then passed.

\end{itemize}

\subsection{Testing}

Testing our assembler code was done much more efficiently than testing our extension, thanks to the provided test suite. Considering that we tested each method after coding it, the tests in the assembler suite passed quite easily. Testing for the extension was more freeform. After each stage in the extension, we ``tested" it by having the other group members look and critique the progress made. After we combined all of the phases, and had the general format of our Guitar Hero-esque game, we invited members of the Department of Computing to try out the initial interface and give us their thoughts. We initially received a wide range of responses, which encouraged us to keep fine-tuning the graphics and sound so that they would synchronize more smoothly. This was the extent of our testing, but we felt this to be appropriate as our extension's success was based off of the satisfaction of our users.

\section{Reflections and Conclusion}

\subsection{Group Reflection}

This group project served as a true test to both our individual programming abilities and our teamwork skills. Throughout the duration of the project, it was essential to maintain good communication, and effectively distribute work. Overall, it is our pleasure to say that the group dynamic was exceptional throughout the duration of the project, and this resulted in completing the first three parts of the project at excellent pace, along with creating an excellent extension.

\vspace{0.2in}

Communication was vital and something we prided ourselves on doing constantly. Facebook was the main form of communication, where, using the Messenger tool, we were able to schedule events that corresponded to group meetings, code sessions, etc. This ensured that all members were prompt and present to put their best foot forward towards all of the group's endeavors. The code was shared through GitLab, and, at first, there were numerous conflicts with merging. However, the group scheduled meetings specifically to address the logistics of pushing code to the repository, which included proper pulling and merging calls and protocol for appropriate Git commits.

\vspace{0.2in}

We prided ourselves on using multiple branches in our Git repository. This ensured that different members could push to different branches without confusion, and this would better organize our code. Helpful commit messages ensured that when it came time to merge our individual branches to the master, this process would be quick, and not take up time that was meant for coding.

\vspace{0.2in}

Splitting the work, for the most part, was ideal. Just as a proper code format was expected by the group, so to was a proper written format for the checkpoint and the report. In this project, most of the report was written by one member to keep a standardized format, but we are okay with this because the other members heavily influenced the report by playing greater roles in the extension. However, for future assignments (especially with next year's group project on the horizon), we aim to better split the written part of the project. The code, from the emulator to the extension, was split very well and we would not change anything with that. We are happy with the group dynamic, as is also seen from the individual reflections.

\subsection{Individual Reflections}

\begin{myquote}
Shravan to fill out
\end{myquote}
\rightline{{\rm --- Shravan Nageswaran}}


\begin{myquote}\noindent
``I am very happy with the performance of my entire group in this project, and I have really enjoyed the challenge. It has been exciting and rewarding to be the group leader and I believe that I have managed the group well throughout. Having a lot of experience in programming has proved very useful during this project, and it meant that I was able to assist my group in the more complicated aspects to the C language. One aspect of the WebPA assessment that I am most proud of is being able to point other people in the right direction when they are struggling with coding - especially when it is a segmentation fault!
\\Reflecting on my progress throughout, I think that I made a slower start to Part I than I had hoped. It took a few days for all of us to get a full understanding of the requirements of the emulator, and the hardest part of the whole project in my opinion, was the initial setup of the emulator, which involved reading in the binary file and loading in the instructions into the \emph{pipeline}. I felt a lot more comfortable after that, and we were able to make much better progress are overcoming this initial hurdle.
\\In the future, if I were to repeat this project, I would have probably started out differently. Instead of trying to understand the  specification in its entirety, I would break down the first part and get straight to programming the binary file reader. That way, we'd be in a better position to continue and work systematically. Other than that, I can't fault anything else in our group and I am extremely happy with the finished products!"
\end{myquote}
\rightline{{\rm --- Jason Lipowicz}}


\begin{myquote}
``Overall, working in this group has been enjoyable and challenging at the same time. While the group dynamic has been outstanding, there were situations where the communication between the group members could have been better. At one point two members of the group worked on the same function in the same file which resulted in many merge conflicts, which then took a long time to solve. However, this was a good learning experience for all of us in terms of both communication and using gitlab appropriately. There were also multiple disagreements on how to implement certain functions as well as extension ideas, but we were always able to find compromises.
\\
I am very grateful to other members of my group for patiently helping me overcome the challenges that I faced, which made me a better C programmer."
\end{myquote}
\rightline{{\rm --- Alexandr Zakon}}


\begin{myquote}
Boaz to fill out
\end{myquote}
\rightline{{\rm --- Boaz Francis}}


\section{Conclusion}


The ARM project and extension have definitely been challenging, but, with the help of our fellow group members, we feel that we have learnt and achieved a lot from this experience.

We believe our efforts not only showcase themselves in the first three parts, but equally in the extension, as well. The depth and nuances of our game required immense effort, efficient communication, and proficient coding amongst our group members, and, while our project is not quite finished, we are pleased with our current work.

Overall, we were satisfied with our group experience, and we feel that is reflected in our product.

\end{document}
