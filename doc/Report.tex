\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{indentfirst}

\let\LaTeXsubsection\subsubsection
\def\subsubsection{\setlength{\parindent}{5mm}\LaTeXsubsection}

\usepackage{titling}
\setlength{\droptitle}{-4em} 

\begin{document}

\title{\textbf{C Project - Final Report}}
\author{Shravan Nageswaran, Alexandr Zakon,\\ Jason Lipowicz, Boaz Francis}
\date{20th June 2017}

\maketitle

\vspace{0.1in}

\section{Implementing the Assembler}

\subsection{Creation of a Symbol Table}

After creating an emulator to read and execute a binary file, our next task was to create an assembler to output ARM-binary code to a source file. Creating the assembler was broken into two steps. The first step was for the group to create a \emph{symbol table} to associate labels with memory addresses. The setup of the symbol table was accomplished through creating two \emph{structs} in C. One improvement that we made while creating objects in the assembler compared to creating objects in the emulator was the fact that we preceded each struct with \emph{typedef}. This allowed us to call the symbol table in other programs without preceding the call with the word \emph{struct}. In order to define the symbol table, we had to first create a separate typedef, which we called \emph{Map}. A Map contained a char pointer to the label, and an integer to its corresponding address. Meanwhile, we created another typedef, called \emph{SymbolTable}, which contained an array of Maps, and an integer corresponding to its size.

\subsection{Generating Instructions}

Once the symbol table structure was created, we had to write code for the assembler to generate binary encodings of instructions that are passed through opcode \emph{mnemonics}. This was the second pass of the assembler's \emph{two-pass} setup. The second pass consisted of two major designs. The first task was to create a tokenizer to break each line into its label. Using the \textbf{strtok\_r} and \textbf{strtol} functions in C, this was quite easy, and we finished this task quickly as a group. the second task was to write functions for the assembler to assemble instructions, where each opcode was mapped to its expected operand count using the aforementioned symbol table abstract data type. Similar to coding the emulator, there were four instructions that we had to code: data processing, multiply, single data transfer, and branch. Thus, we assigned each group member an instruction to handle, and in turn the dynamic of the group in Part II was notably smoother than its dynamic in Part I. Tasks were distributed much more efficiently, which led to a faster completion of the assembler. However, this required more time to be spent on standardizing the code format, as many parts of the second pass of the assembler were coded independently.

\section{Extension}

\subsection{Concept}

Creating the assembler and emulator made us appreciate the designs of computer architecture. However, for our extension, we also wanted to immerse ourselves in the interactive aspects of C, and we endeavored to create an extension that would let us use GUIs, I/O, etc. Our main objective was to create an extension that would respond in real-time to user input, so we decided to code a game similar to the classic video game \emph{Guitar Hero}. Our vision for this was the synchronization of an animated GUI with chosen sound files. Different coloured buttons would flash on the GUI, which would correspond to "notes" generated from the sound file. The user would have to press the corresponding key to the button on the keyboard before the next button presented itself.

\subsection{Design}

*Will elaborate*

\subsection{Challenges}

*Will elaborate*

\subsection{Testing}

*Will elaborate*

\section{Reflections and Conclusion}

\subsection{Group Reflection}

\subsection{Individual Reflections}

\subsubsection{Shravan Nageswaran} \emph{Shravan to fill out}


\subsubsection{Jason Lipowicz}

I am very happy with the performance of my entire group in this project, and I have really enjoyed the challenge. It has been exciting and rewarding to be the group leader and I believe that I have managed the group well throughout. Having a lot of experience in programming has proved very useful during this project, and it meant that I was able to assist my group in the more complicated aspects to the C language. One aspect of the WebPA assessment that I am most proud of is being able to point other people in the right direction when they are struggling with coding - especially when it is a segmentation fault!
\\\\ Reflecting on my progress throughout, I think that I made a slower start to Part I than I had hoped. It took a few days for all of us to get a full understanding of the requirements of the emulator, and the hardest part of the whole project in my opinion, was the initial setup of the emulator, which involved reading in the binary file and loading in the instructions into the \emph{pipeline}. I felt a lot more comfortable after that, and we were able to make much better progress are overcoming this initial hurdle.
\\\\ In the future, if I were to repeat this project, I would have probably started out differently. Instead of trying to understand the  specification in its entirety, I would break down the first part and get straight to programming the binary file reader. That way, we'd be in a better position to continue and work systematically. Other than that, I can't fault anything else in our group and I am extermely happy with the finished products!

\subsubsection{Alexandr Zakon} \emph{Alexandr to fill out}


\subsubsection{Boaz Francis} \emph{Boaz to fill out}

\section{Conclusion}

\end{document}
